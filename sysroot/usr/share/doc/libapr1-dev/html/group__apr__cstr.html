<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Apache Portable Runtime: C (POSIX) locale string functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Apache Portable Runtime
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">C (POSIX) locale string functions<div class="ingroups"><a class="el" href="group___a_p_r.html">Apache Portability Runtime library</a> &raquo; <a class="el" href="group__apr__strings.html">String routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for C (POSIX) locale string functions:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__apr__cstr.png" border="0" alt="" usemap="#group____apr____cstr"/>
<!-- MAP 0 -->
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga50b5f39a52d18f3211440602642b5702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga50b5f39a52d18f3211440602642b5702">apr_cstr_split</a> (const char *input, const char *sep_chars, int chop_whitespace, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr class="separator:ga50b5f39a52d18f3211440602642b5702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380343bfadb7332ece4c042701fa065a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga380343bfadb7332ece4c042701fa065a">apr_cstr_split_append</a> (<a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *array, const char *input, const char *sep_chars, int chop_whitespace, <a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *pool)</td></tr>
<tr class="separator:ga380343bfadb7332ece4c042701fa065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59052f471fdbe1456fe283f665395be2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga59052f471fdbe1456fe283f665395be2">apr_cstr_match_glob_list</a> (const char *str, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *list)</td></tr>
<tr class="separator:ga59052f471fdbe1456fe283f665395be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5884f17dd18202b5dd4388c6664e794b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga5884f17dd18202b5dd4388c6664e794b">apr_cstr_match_list</a> (const char *str, const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *list)</td></tr>
<tr class="separator:ga5884f17dd18202b5dd4388c6664e794b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43296ec627eefd3d55de5cfb13cc8935"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga43296ec627eefd3d55de5cfb13cc8935">apr_cstr_tokenize</a> (const char *sep, char **str)</td></tr>
<tr class="separator:ga43296ec627eefd3d55de5cfb13cc8935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d776750e0b201588e1c24501cd65f71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga6d776750e0b201588e1c24501cd65f71">apr_cstr_count_newlines</a> (const char *msg)</td></tr>
<tr class="separator:ga6d776750e0b201588e1c24501cd65f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07584e519301a67ff066c30be2785e44"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga07584e519301a67ff066c30be2785e44">apr_cstr_casecmp</a> (const char *str1, const char *str2)</td></tr>
<tr class="separator:ga07584e519301a67ff066c30be2785e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f4fcf23a4c707dfa83723511fcdfd80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga4f4fcf23a4c707dfa83723511fcdfd80">apr_cstr_casecmpn</a> (const char *str1, const char *str2, apr_size_t n)</td></tr>
<tr class="separator:ga4f4fcf23a4c707dfa83723511fcdfd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga701ca1217727de647676d41809b5ef90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga701ca1217727de647676d41809b5ef90">apr_cstr_strtoi64</a> (apr_int64_t *n, const char *str, apr_int64_t minval, apr_int64_t maxval, int base)</td></tr>
<tr class="separator:ga701ca1217727de647676d41809b5ef90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22106194f17480bb9d18be39cfed1dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#gac22106194f17480bb9d18be39cfed1dd">apr_cstr_atoi64</a> (apr_int64_t *n, const char *str)</td></tr>
<tr class="separator:gac22106194f17480bb9d18be39cfed1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad363278febcb4e43ff0affe51a5c8c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#gad363278febcb4e43ff0affe51a5c8c68">apr_cstr_atoi</a> (int *n, const char *str)</td></tr>
<tr class="separator:gad363278febcb4e43ff0affe51a5c8c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6398304e57dfb85546234ba9b466ec76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga6398304e57dfb85546234ba9b466ec76">apr_cstr_strtoui64</a> (apr_uint64_t *n, const char *str, apr_uint64_t minval, apr_uint64_t maxval, int base)</td></tr>
<tr class="separator:ga6398304e57dfb85546234ba9b466ec76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0439b516bc8fd258a9b2c7271fe8347d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga0439b516bc8fd258a9b2c7271fe8347d">apr_cstr_atoui64</a> (apr_uint64_t *n, const char *str)</td></tr>
<tr class="separator:ga0439b516bc8fd258a9b2c7271fe8347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c90f8722d90f833af3e003b9420090d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga4c90f8722d90f833af3e003b9420090d">apr_cstr_atoui</a> (unsigned int *n, const char *str)</td></tr>
<tr class="separator:ga4c90f8722d90f833af3e003b9420090d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04e457538985940b16f8759076ca3068"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__apr__cstr.html#ga04e457538985940b16f8759076ca3068">apr_cstr_skip_prefix</a> (const char *str, const char *prefix)</td></tr>
<tr class="separator:ga04e457538985940b16f8759076ca3068"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The apr_cstr_* functions provide traditional C char * string text handling, and notabilty they treat all text in the C (a.k.a. POSIX) locale using the minimal POSIX character set, represented in either ASCII or a corresponding EBCDIC subset.</p>
<p>Character values outside of that set are treated as opaque bytes, and all multi-byte character sequences are handled as individual distinct octets.</p>
<p>Multi-byte characters sequences whose octets fall in the ASCII range cause unexpected results, such as in the ISO-2022-JP code page where ASCII octets occur within both shift-state and multibyte sequences.</p>
<p>In the case of the UTF-8 encoding, all multibyte characters all fall outside of the C/POSIX range of characters, so these functions are generally safe to use on UTF-8 strings. The programmer must be aware that each octet may not represent a distinct printable character in such encodings.</p>
<p>The standard C99/POSIX string functions, rather than apr_cstr, should be used in all cases where the current locale and encoding of the text is significant. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad363278febcb4e43ff0affe51a5c8c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad363278febcb4e43ff0affe51a5c8c68">&#9670;&nbsp;</a></span>apr_cstr_atoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_cstr_atoi </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the C string <em>str</em> into a 32 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for <a class="el" href="group__apr__cstr.html#ga701ca1217727de647676d41809b5ef90">apr_cstr_strtoi64()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="gac22106194f17480bb9d18be39cfed1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac22106194f17480bb9d18be39cfed1dd">&#9670;&nbsp;</a></span>apr_cstr_atoi64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_cstr_atoi64 </td>
          <td>(</td>
          <td class="paramtype">apr_int64_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the C string <em>str</em> into a 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for <a class="el" href="group__apr__cstr.html#ga701ca1217727de647676d41809b5ef90">apr_cstr_strtoi64()</a>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga4c90f8722d90f833af3e003b9420090d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c90f8722d90f833af3e003b9420090d">&#9670;&nbsp;</a></span>apr_cstr_atoui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_cstr_atoui </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the C string <em>str</em> into an unsigned 32 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for <a class="el" href="group__apr__cstr.html#ga6398304e57dfb85546234ba9b466ec76">apr_cstr_strtoui64()</a>, including the upper limit of APR_INT64_MAX.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga0439b516bc8fd258a9b2c7271fe8347d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0439b516bc8fd258a9b2c7271fe8347d">&#9670;&nbsp;</a></span>apr_cstr_atoui64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_cstr_atoui64 </td>
          <td>(</td>
          <td class="paramtype">apr_uint64_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the C string <em>str</em> into an unsigned 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base 10. Raise an error if conversion fails (e.g. due to overflow).</p>
<p>The behaviour otherwise is as described for <a class="el" href="group__apr__cstr.html#ga6398304e57dfb85546234ba9b466ec76">apr_cstr_strtoui64()</a>, including the upper limit of APR_INT64_MAX.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga07584e519301a67ff066c30be2785e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07584e519301a67ff066c30be2785e44">&#9670;&nbsp;</a></span>apr_cstr_casecmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_cstr_casecmp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a case-insensitive comparison of two strings <em>atr1</em> and <em>atr2</em>, treating upper and lower case values of the 26 standard C/POSIX alphabetic characters as equivalent. Extended latin characters outside of this set are treated as unique octets, irrespective of the current locale.</p>
<p>Returns in integer greater than, equal to, or less than 0, according to whether <em>str1</em> is considered greater than, equal to, or less than <em>str2</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga4f4fcf23a4c707dfa83723511fcdfd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f4fcf23a4c707dfa83723511fcdfd80">&#9670;&nbsp;</a></span>apr_cstr_casecmpn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_cstr_casecmpn </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform a case-insensitive comparison of two strings <em>atr1</em> and <em>atr2</em>, treating upper and lower case values of the 26 standard C/POSIX alphabetic characters as equivalent. Extended latin characters outside of this set are treated as unique octets, irrespective of the current locale.</p>
<p>Returns in integer greater than, equal to, or less than 0, according to whether <em>str1</em> is considered greater than, equal to, or less than <em>str2</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga6d776750e0b201588e1c24501cd65f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d776750e0b201588e1c24501cd65f71">&#9670;&nbsp;</a></span>apr_cstr_count_newlines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_cstr_count_newlines </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of line breaks in <em>msg</em>, allowing any kind of newline termination (CR, LF, CRLF, or LFCR), even inconsistent.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga59052f471fdbe1456fe283f665395be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59052f471fdbe1456fe283f665395be2">&#9670;&nbsp;</a></span>apr_cstr_match_glob_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_cstr_match_glob_list </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>TRUE</code> iff <em>str</em> matches any of the elements of <em>list</em>, a list of zero or more glob patterns.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a id="ga5884f17dd18202b5dd4388c6664e794b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5884f17dd18202b5dd4388c6664e794b">&#9670;&nbsp;</a></span>apr_cstr_match_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_cstr_match_list </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>TRUE</code> iff <em>str</em> exactly matches any of the elements of <em>list</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a id="ga04e457538985940b16f8759076ca3068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04e457538985940b16f8759076ca3068">&#9670;&nbsp;</a></span>apr_cstr_skip_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_cstr_skip_prefix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skip the common prefix <em>prefix</em> from the C string <em>str</em>, and return a pointer to the next character after the prefix. Return <code>NULL</code> if <em>str</em> does not start with <em>prefix</em>.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga50b5f39a52d18f3211440602642b5702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b5f39a52d18f3211440602642b5702">&#9670;&nbsp;</a></span>apr_cstr_split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a>* apr_cstr_split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chop_whitespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide <em>input</em> into substrings, interpreting any char from <em>sep</em> as a token separator.</p>
<p>Return an array of copies of those substrings (plain const char*), allocating both the array and the copies in <em>pool</em>.</p>
<p>None of the elements added to the array contain any of the characters in <em>sep_chars</em>, and none of the new elements are empty (thus, it is possible that the returned array will have length zero).</p>
<p>If <em>chop_whitespace</em> is TRUE, then remove leading and trailing whitespace from the returned strings.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a id="ga380343bfadb7332ece4c042701fa065a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga380343bfadb7332ece4c042701fa065a">&#9670;&nbsp;</a></span>apr_cstr_split_append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_cstr_split_append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__array__header__t.html">apr_array_header_t</a> *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep_chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>chop_whitespace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apr__pools.html#gaf137f28edcf9a086cd6bc36c20d7cdfb">apr_pool_t</a> *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like <a class="el" href="group__apr__cstr.html#ga50b5f39a52d18f3211440602642b5702">apr_cstr_split()</a>, but append to existing <em>array</em> instead of creating a new one. Allocate the copied substrings in <em>pool</em> (i.e., caller decides whether or not to pass <em>array-&gt;pool</em> as <em>pool</em>).</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6 </dd></dl>

</div>
</div>
<a id="ga701ca1217727de647676d41809b5ef90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga701ca1217727de647676d41809b5ef90">&#9670;&nbsp;</a></span>apr_cstr_strtoi64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_cstr_strtoi64 </td>
          <td>(</td>
          <td class="paramtype">apr_int64_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int64_t&#160;</td>
          <td class="paramname"><em>minval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_int64_t&#160;</td>
          <td class="paramname"><em>maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the C string <em>str</em> into a 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base <em>base</em>. Raise an error if conversion fails (e.g. due to overflow), or if the converted number is smaller than <em>minval</em> or larger than <em>maxval</em>.</p>
<p>Leading whitespace in <em>str</em> is skipped in a locale-dependent way. After that, the string may contain an optional '+' (positive, default) or '-' (negative) character, followed by an optional '0x' prefix if <em>base</em> is 0 or 16, followed by numeric digits appropriate for the base. If there are any more characters after the numeric digits, an error is returned.</p>
<p>If <em>base</em> is zero, then a leading '0x' or '0X' prefix means hexadecimal, else a leading '0' means octal (implemented, though not documented, in <a class="el" href="group__apr__strings.html#ga1da34829609e8976f498b235afd6cbe4">apr_strtoi64()</a> in APR 0.9.0 through 1.5.0), else use base ten.</p>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga6398304e57dfb85546234ba9b466ec76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6398304e57dfb85546234ba9b466ec76">&#9670;&nbsp;</a></span>apr_cstr_strtoui64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apr__errno.html#gaf76ee4543247e9fb3f3546203e590a6c">apr_status_t</a> apr_cstr_strtoui64 </td>
          <td>(</td>
          <td class="paramtype">apr_uint64_t *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_uint64_t&#160;</td>
          <td class="paramname"><em>minval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_uint64_t&#160;</td>
          <td class="paramname"><em>maxval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the C string <em>str</em> into an unsigned 64 bit number, and return it in <em>*n</em>. Assume that the number is represented in base <em>base</em>. Raise an error if conversion fails (e.g. due to overflow), or if the converted number is smaller than <em>minval</em> or larger than <em>maxval</em>.</p>
<p>Leading whitespace in <em>str</em> is skipped in a locale-dependent way. After that, the string may contain an optional '+' (positive, default) or '-' (negative) character, followed by an optional '0x' prefix if <em>base</em> is 0 or 16, followed by numeric digits appropriate for the base. If there are any more characters after the numeric digits, an error is returned.</p>
<p>If <em>base</em> is zero, then a leading '0x' or '0X' prefix means hexadecimal, else a leading '0' means octal (as implemented, though not documented, in <a class="el" href="group__apr__strings.html#ga1da34829609e8976f498b235afd6cbe4">apr_strtoi64()</a>, else use base ten.</p>
<dl class="section warning"><dt>Warning</dt><dd>The implementation returns APR_ERANGE if the parsed number is greater than APR_INT64_MAX, even if it is not greater than <em>maxval</em>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
<a id="ga43296ec627eefd3d55de5cfb13cc8935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43296ec627eefd3d55de5cfb13cc8935">&#9670;&nbsp;</a></span>apr_cstr_tokenize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* apr_cstr_tokenize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next token from <em>*str</em> interpreting any char from <em>sep</em> as a token separator. Separators at the beginning of <em>str</em> will be skipped. Returns a pointer to the beginning of the first token in <em>*str</em> or NULL if no token is left. Modifies <em>str</em> such that the next call will return the next token.</p>
<dl class="section note"><dt>Note</dt><dd>The content of <em>*str</em> may be modified by this function.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>New in 1.6. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
